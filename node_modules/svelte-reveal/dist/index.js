var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      typeof self !== "undefined" ? self : exports,
      [],
      Math
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// src/internal/constants.ts
var ROOT_MARGIN_REGEX = /^(-?(0|([1-9]\d*))(px|%)?\s*){0,4}$/;

// src/internal/validations.ts
var hasValidRange = (property, min, max) => {
  return property >= min && property <= max;
};
var isPositive = (property) => property >= 0;
var isPositiveInteger = (property) => {
  return isPositive(property) && Number.isInteger(property);
};
var areOptionsValid = (options) => {
  const { threshold, opacity, delay, duration, blur, scale, rootMargin } = options;
  return ROOT_MARGIN_REGEX.test(rootMargin) && hasValidRange(threshold, 0, 1) && hasValidRange(opacity, 0, 1) && isPositive(delay) && isPositive(duration) && isPositive(blur) && isPositive(scale);
};

// src/internal/styling/breakpoints.ts
var hasOverlappingBreakpoints = (responsive) => {
  const { mobile, tablet, laptop, desktop } = responsive;
  return mobile.breakpoint > tablet.breakpoint || tablet.breakpoint > laptop.breakpoint || laptop.breakpoint > desktop.breakpoint;
};
var hasValidBreakpoints = (responsive) => {
  const breakpoints = Object.values(responsive).map((device) => device.breakpoint);
  const breakpointsOverlap = hasOverlappingBreakpoints(responsive);
  const allBreakpointsPositive = breakpoints.every((breakpoint) => isPositiveInteger(breakpoint));
  return !breakpointsOverlap && allBreakpointsPositive;
};

// src/internal/styling/classesGeneration.ts
var import_seedrandom = __toESM(require_seedrandom2(), 1);

// src/internal/config.ts
var defOpts = {
  disable: false,
  debug: false,
  ref: "",
  highlightLogs: false,
  highlightColor: "tomato",
  root: null,
  rootMargin: "0px 0px 0px 0px",
  threshold: 0.6,
  transition: "fly",
  reset: false,
  duration: 800,
  delay: 0,
  easing: "custom",
  customEasing: [0.25, 0.1, 0.25, 0.1],
  x: -20,
  y: -20,
  rotate: -360,
  opacity: 0,
  blur: 16,
  scale: 0,
  onRevealStart: () => null,
  onRevealEnd: () => null,
  onResetStart: () => null,
  onResetEnd: () => null,
  onMount: () => null,
  onUpdate: () => null,
  onDestroy: () => null
};
var config = {
  dev: true,
  once: false,
  responsive: {
    mobile: {
      enabled: true,
      breakpoint: 425
    },
    tablet: {
      enabled: true,
      breakpoint: 768
    },
    laptop: {
      enabled: true,
      breakpoint: 1440
    },
    desktop: {
      enabled: true,
      breakpoint: 2560
    }
  }
};

// src/internal/utils.ts
var clone = (item) => JSON.parse(JSON.stringify(item));
var clean = (str) => str.trim().replace(/[\n|\t]/g, "").replace(/\s(\s+)/g, " ");
var getConfigClone = () => clone(config);
var createObserverConfig = (observerConfig) => {
  return {
    root: (observerConfig == null ? void 0 : observerConfig.root) || defOpts.root,
    rootMargin: (observerConfig == null ? void 0 : observerConfig.rootMargin) || defOpts.rootMargin,
    threshold: (observerConfig == null ? void 0 : observerConfig.threshold) || defOpts.threshold
  };
};
var createFinalOptions = (userOptions) => {
  return Object.assign({}, defOpts, userOptions);
};

// src/internal/styling/mediaQueries.ts
var createQuery = (devices, previousDevice, start, end) => {
  const smallest = Math.min(...devices.map(([, settings]) => settings.breakpoint));
  const largest = Math.max(...devices.map(([, settings]) => settings.breakpoint));
  if (previousDevice === void 0 || start === smallest) {
    return `(max-width: ${end}px)`;
  }
  if (end === largest) {
    return `(min-width: ${previousDevice[1].breakpoint + 1}px)`;
  }
  return `(min-width: ${previousDevice[1].breakpoint + 1}px) and (max-width: ${end}px)`;
};
var getOptimalQueries = (devices) => {
  const queries = [];
  for (let i = 0; i < devices.length; ) {
    const startDevice = devices[i];
    if (!startDevice || !startDevice[1].enabled) {
      i++;
      continue;
    }
    let j = i;
    let query = "";
    let endDevice = startDevice;
    while (j < devices.length && endDevice[1].enabled) {
      const start = startDevice[1].breakpoint;
      const end = endDevice[1].breakpoint;
      const previous = devices[i - 1];
      query = createQuery(devices, previous, start, end);
      j++;
      endDevice = devices[j] || endDevice;
    }
    queries.push(query);
    i = j;
  }
  return queries;
};
var addMediaQueries = (styles, responsive = config.responsive) => {
  if (!hasValidBreakpoints(responsive)) {
    throw new Error("Cannot create media queries due to invalid breakpoints");
  }
  const devices = Object.entries(responsive);
  const allDevicesEnabled = devices.every(([, settings]) => settings.enabled);
  const allDevicesDisabled = devices.every(([, settings]) => !settings.enabled);
  if (allDevicesEnabled)
    return styles;
  if (allDevicesDisabled) {
    return clean(`
			@media not all {
				${styles}
			}
		`);
  }
  const query = getOptimalQueries(devices).join(", ");
  return clean(`
		@media ${query} {
			${styles}
		}
	`);
};

// src/internal/DOM.ts
var markRevealNode = (revealNode) => {
  revealNode.setAttribute("data-action", "reveal");
  return revealNode;
};
var activateRevealNode = (revealNode, transitionPropertiesCSSClass, transitionDeclarationCSSClass, options) => {
  markRevealNode(revealNode);
  const transitionDeclaration = createTransitionDeclarationCSS(transitionDeclarationCSSClass, options);
  const transitionProperties = createTransitionPropertiesCSS(transitionPropertiesCSSClass, options);
  const stylesheet = document.querySelector('style[data-action="reveal"]');
  if (stylesheet) {
    const existingRevealStyles = stylesheet.innerHTML;
    const nodeRevealStyles = clean([transitionProperties, transitionDeclaration].join(" "));
    const updatedRevealStyles = mergeRevealStyles(existingRevealStyles, nodeRevealStyles);
    stylesheet.innerHTML = updatedRevealStyles;
    revealNode.classList.add(transitionPropertiesCSSClass);
    revealNode.classList.add(transitionDeclarationCSSClass);
  }
  return revealNode;
};
var getRevealNode = (node) => {
  if (node.style.length === 0)
    return node;
  const wrapper = document.createElement("div");
  wrapper.appendChild(node);
  return wrapper;
};
var createObserver = (canDebug, highlightText, revealNode, options, className) => {
  const { ref, reset, duration, delay, threshold, onResetStart, onResetEnd, onRevealEnd } = options;
  const observerConfig = createObserverConfig();
  return new IntersectionObserver((entries, observer) => {
    if (canDebug) {
      const entry = entries[0];
      if (!entry) {
        throw new Error("Intersection Observer entry is undefined");
      }
      const entryTarget = entry.target;
      if (entryTarget === revealNode) {
        console.groupCollapsed(`%cRef: ${ref} (Intersection Observer Callback)`, highlightText);
        console.log(entry);
        console.log(observerConfig);
        console.groupEnd();
      }
    }
    entries.forEach((entry) => {
      if (reset && !entry.isIntersecting) {
        onResetStart(revealNode);
        revealNode.classList.add(className);
        setTimeout(() => onResetEnd(revealNode), duration + delay);
      } else if (entry.intersectionRatio >= threshold) {
        setTimeout(() => onRevealEnd(revealNode), duration + delay);
        revealNode.classList.remove(className);
        if (!reset)
          observer.unobserve(revealNode);
      }
    });
  }, observerConfig);
};
var logInfo = (finalOptions, revealNode) => {
  const { debug, ref, highlightLogs, highlightColor } = finalOptions;
  const canDebug = config.dev && debug && ref !== "";
  const highlightText = `color: ${highlightLogs ? highlightColor : "#B4BEC8"}`;
  if (canDebug) {
    console.groupCollapsed(`%cRef: ${ref}`, highlightText);
    console.groupCollapsed("%cNode", highlightText);
    console.log(revealNode);
    console.groupEnd();
    console.groupCollapsed("%cConfig", highlightText);
    console.log(config);
    console.groupEnd();
    console.groupCollapsed("%cOptions", highlightText);
    console.log(finalOptions);
    console.groupEnd();
  }
  return [canDebug, highlightText];
};

// src/internal/styling/stylesExtraction.ts
var extractCSSRules = (styles) => {
  return clean(styles).split(";").filter((rule) => rule !== "").map((rule) => rule.trim());
};
var sanitizeStyles = (styles) => {
  return extractCSSRules(styles).join("; ").concat("; ");
};

// src/internal/styling/stylesGeneration.ts
var createStylesheet = () => {
  const style = document.createElement("style");
  style.setAttribute("type", "text/css");
  markRevealNode(style);
  const head = document.querySelector("head");
  if (head !== null)
    head.appendChild(style);
};
var addVendorPrefixes = (unprefixedStyles) => {
  const rules = extractCSSRules(unprefixedStyles);
  const prefixedStyles = rules.reduce((styles, rule) => {
    const [property, value] = rule.trim().split(":").map((r) => r.trim());
    const newStyles = sanitizeStyles(`
			-webkit-${property}: ${value};
			-ms-${property}: ${value};
			${property}: ${value};
		`);
    return styles.concat(newStyles);
  }, "");
  return prefixedStyles.trim();
};

// src/internal/styling/stylesRetrieval.ts
var mergeRevealStyles = (existingRevealStyles, nodeRevealStyles) => {
  const combinedRevealStyles = [getMinifiedStylesFromQuery(existingRevealStyles), nodeRevealStyles].join(" ");
  return addMediaQueries(combinedRevealStyles).trim();
};
var getMinifiedStylesFromQuery = (query) => {
  const cleanQuery = clean(query.trim());
  const isMediaQuery = cleanQuery.startsWith("@media");
  if (!isMediaQuery)
    return cleanQuery;
  const separator = "<opening_media_query_brace>";
  const queryFromOpeningBrace = cleanQuery.replace(/{/, separator).split(separator)[1];
  if (!queryFromOpeningBrace) {
    throw new Error("Invalid media query");
  }
  const queryContent = queryFromOpeningBrace.slice(0, -1);
  return queryContent.trim();
};
var getTransitionPropertiesCSSRules = (transition, options) => {
  const { x, y, rotate, opacity, blur, scale } = Object.assign({}, defOpts, options);
  const transitions = {
    fly: `
			opacity: ${opacity};
			transform: translateY(${y}px);
		`,
    fade: `
			opacity: ${opacity};
		`,
    blur: `
			opacity: ${opacity};
			filter: blur(${blur}px);
		`,
    scale: `
			opacity: ${opacity};
			transform: scale(${scale});
		`,
    slide: `
			opacity: ${opacity};
			transform: translateX(${x}px);
		`,
    spin: `
			opacity: ${opacity};
			transform: rotate(${rotate}deg);
		`
  };
  if (!Object.keys(transitions).includes(transition)) {
    throw new Error("Invalid CSS class name");
  }
  const styles = transitions[transition];
  return addVendorPrefixes(styles);
};
var getEasingFunction = (easing, customEasing) => {
  if (easing === "custom" && customEasing) {
    return `cubic-bezier(${customEasing.join(", ")})`;
  }
  const weights = {
    linear: [0, 0, 1, 1],
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  if (easing !== "custom" && Object.keys(weights).includes(easing)) {
    return `cubic-bezier(${weights[easing].join(", ")})`;
  }
  throw new Error("Invalid easing function");
};

// src/internal/styling/classesGeneration.ts
var getRevealClassNames = (ref, transition) => {
  const createClassNameTokens = (tokensArray) => tokensArray.filter((token) => token && token !== "").map((token) => token.replace(/\s/g, "-")).join("__");
  const createClassName = (tokens2, uid2) => `sr__${tokens2}__${uid2}`;
  const tokens = {
    transition: [ref, "transition", transition],
    properties: [ref, "properties", transition]
  };
  const transitionClassTokens = createClassNameTokens(tokens.transition);
  const propertiesClassTokens = createClassNameTokens(tokens.properties);
  const seed = document.querySelectorAll('[data-action="reveal"]').length.toString();
  const uid = (0, import_seedrandom.default)(seed)().toString().slice(2);
  const transitionDeclaration = createClassName(transitionClassTokens, uid);
  const transitionProperties = createClassName(propertiesClassTokens, uid);
  return [transitionDeclaration, transitionProperties];
};
var createTransitionDeclarationCSS = (className, options) => {
  const duration = options.duration / 1e3;
  const delay = options.delay / 1e3;
  const easingFunction = getEasingFunction(options.easing, options.customEasing);
  return `
		.${className} {
			transition: all ${duration}s ${delay}s ${easingFunction};
		}
	`;
};
var createTransitionPropertiesCSS = (className, options) => {
  const { transition } = options;
  const transitionPropertiesRules = getTransitionPropertiesCSSRules(transition, options);
  return `
		.${className} {
			${transitionPropertiesRules}
		}
	`;
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var resolved_promise = Promise.resolve();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}

// src/internal/stores.ts
var isStyleTagCreated = writable(false);
var hasPageReloaded = writable(false);

// src/internal/reveal.ts
var reveal = (node, options = defOpts) => {
  const finalOptions = createFinalOptions(options);
  if (!areOptionsValid(finalOptions)) {
    throw new Error("Invalid options");
  }
  const { transition, disable, ref, onRevealStart, onMount, onUpdate, onDestroy } = finalOptions;
  const revealNode = getRevealNode(node);
  const [transitionDeclaration, transitionProperties] = getRevealClassNames(ref, transition);
  onMount(revealNode);
  const [canDebug, highlightText] = logInfo(finalOptions, revealNode);
  let reloaded = false;
  const unsubscribeReloaded = hasPageReloaded.subscribe((value) => reloaded = value);
  const navigation = window.performance.getEntriesByType("navigation");
  let navigationType = "";
  if (navigation.length > 0) {
    navigationType = navigation[0].type;
  } else {
    navigationType = window.performance.navigation.type;
  }
  if (navigationType === "reload" || navigationType === 1)
    hasPageReloaded.set(true);
  if (disable || config.once && reloaded)
    return {};
  let styleTagExists = false;
  const unsubscribeStyleTag = isStyleTagCreated.subscribe((value) => styleTagExists = value);
  if (!styleTagExists) {
    createStylesheet();
    isStyleTagCreated.set(true);
  }
  onRevealStart(revealNode);
  activateRevealNode(revealNode, transitionDeclaration, transitionProperties, finalOptions);
  const observerInstance = createObserver(canDebug, highlightText, revealNode, finalOptions, transitionDeclaration);
  observerInstance.observe(revealNode);
  console.groupEnd();
  return {
    update() {
      onUpdate(revealNode);
    },
    destroy() {
      onDestroy(revealNode);
      unsubscribeStyleTag();
      unsubscribeReloaded();
      observerInstance.disconnect();
    }
  };
};

// src/internal/API.ts
var setDev = (dev) => {
  config.dev = dev;
  return config;
};
var setOnce = (once) => {
  config.once = once;
  return config;
};
var setDeviceStatus = (device, status) => {
  return setDevicesStatus([device], status);
};
var setDevicesStatus = (devices, status) => {
  if (devices.length > 0) {
    const uniqueDevices = [...new Set(devices)];
    uniqueDevices.forEach((device) => config.responsive[device].enabled = status);
    return config;
  }
  throw new Error("At least one device required");
};
var setDeviceBreakpoint = (device, breakpoint) => {
  const configClone = getConfigClone();
  configClone.responsive[device].breakpoint = breakpoint;
  if (!hasValidBreakpoints(configClone.responsive)) {
    throw new Error("Invalid breakpoints");
  }
  config.responsive[device].breakpoint = breakpoint;
  return config;
};
var setDevice = (device, settings) => {
  const configClone = getConfigClone();
  configClone.responsive[device] = settings;
  if (!hasValidBreakpoints(configClone.responsive)) {
    throw new Error("Invalid breakpoints");
  }
  config.responsive[device] = settings;
  return config;
};
var setResponsive = (responsive) => {
  if (!hasValidBreakpoints(responsive)) {
    throw new Error("Invalid breakpoints");
  }
  config.responsive = responsive;
  return config;
};
var setObserverRoot = (root) => {
  defOpts.root = root;
  return createObserverConfig();
};
var setObserverRootMargin = (rootMargin) => {
  const isValidMargin = ROOT_MARGIN_REGEX.test(rootMargin);
  if (!isValidMargin) {
    throw new SyntaxError("Invalid rootMargin syntax");
  }
  defOpts.rootMargin = rootMargin;
  return createObserverConfig();
};
var setObserverThreshold = (threshold) => {
  if (!hasValidRange(threshold, 0, 1)) {
    throw new RangeError("Threshold must be between 0.0 and 1.0");
  }
  defOpts.threshold = threshold;
  return createObserverConfig();
};
var setObserverConfig = (observerConfig) => {
  const newObserverConfig = createObserverConfig(observerConfig);
  setObserverRoot(newObserverConfig.root);
  setObserverRootMargin(newObserverConfig.rootMargin);
  setObserverThreshold(newObserverConfig.threshold);
  return newObserverConfig;
};
var setConfig = (userConfig) => {
  setDev(userConfig.dev);
  setOnce(userConfig.once);
  setResponsive(userConfig.responsive);
  return config;
};
var setDefaultOptions = (options) => {
  const validOptions = createFinalOptions(options);
  if (!areOptionsValid(validOptions)) {
    throw new Error("Invalid options");
  }
  return Object.assign(defOpts, validOptions);
};
export {
  reveal,
  setConfig,
  setDefaultOptions,
  setDev,
  setDevice,
  setDeviceBreakpoint,
  setDeviceStatus,
  setDevicesStatus,
  setObserverConfig,
  setObserverRoot,
  setObserverRootMargin,
  setObserverThreshold,
  setOnce,
  setResponsive
};
